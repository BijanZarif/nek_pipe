c-----------------------------------------------------------------------
c  Couette flow
c  jcanton@mech.kth.se
c-----------------------------------------------------------------------

      subroutine uservp (ix,iy,iz,ieg)

         implicit none

         include 'SIZE_DEF'
         include 'SIZE'  ! LDIMT needed by NEKUSE
         include 'NEKUSE_DEF'
         include 'NEKUSE' ! udiff, utrans

         integer, intent(in) :: ix,iy,iz,ieg

         udiff = 0.0
         utrans = 0.0

      return
      end

c-----------------------------------------------------------------------

      subroutine userf  (ix,iy,iz,ieg)

         implicit none

         include 'SIZE_DEF'
         include 'SIZE'  ! LDIMT needed by NEKUSE
         include 'NEKUSE_DEF'
         include 'NEKUSE' ! ff[xyz]

         integer, intent(in) :: ix,iy,iz,ieg

         ffx = 0.0
         ffy = 0.0
         ffz = 0.0

      return
      end

c-----------------------------------------------------------------------

      subroutine userq  (ix,iy,iz,ieg)

         implicit none

         include 'SIZE_DEF'
         include 'SIZE'  ! LDIMT needed by NEKUSE
         include 'NEKUSE_DEF'
         include 'NEKUSE' ! qvol

         integer, intent(in) :: ix,iy,iz,ieg

         QVOL = 0.0
         ! SOURCE = 0.0 (cannot find where this is)

      return
      end

c-----------------------------------------------------------------------

      subroutine userchk


         implicit none

         include 'SIZE_DEF'
         include 'SIZE'  ! L[XYZ]1, LELV, NID
         include 'MASS_DEF'
         include 'MASS' ! BM1
         include 'TSTEP_DEF'
         include 'TSTEP' ! ISTEP,IOSTEP
         include 'INPUT_DEF'
         include 'INPUT' ! PARAM
         include 'SOLN_DEF'      
         include 'SOLN'  ! V[XYZ],V[XYZ]P
         ! include 'CHKPOINT'

         !real, external :: dnekclock ! defined in comm_mpi.f
         real, external :: glmin, glmax ! defined in math.f


         real divv
         COMMON /SCRUZ/  DIVV (LX2,LY2,LZ2,LELV)
         real work1(lx1,ly1,lz1,lelv),
     $        work2(lx1,ly1,lz1,lelv),
     $        divm1(lx1,ly1,lz1,lelv)
         integer ntdump
         common /rdump/ ntdump

         real rtime, tic
         save rtime
         data rtime  /0./
         real divmax

         real work3(lx1,ly1,lz1,lelv),
     $        work4(lx1,ly1,lz1,lelv),
     $        v_s(lx1,ly1,lz1,lelv), ! streamwise
     $        omega_s(lx1,ly1,lz1,lelv)
         real vorticity(lx1*ly1*lz1*lelv,3)
         real phi(lx1,ly1,lz1,lelv)
         real h1(lx1,ly1,lz1,lelv)
         real h2(lx1,ly1,lz1,lelv)
         real rhs(lx1,ly1,lz1,lelv)

         integer n, nn, maxit
         real toler, p22 

         n  = nelv*lx1*ly1*lz1
         nn = nelv*nx1*ny1*nz1

         ! Output maximum of divergence
         ! This maps divergence from pressure (Pn-2) to velocity mesh (Pn)
         call mappr(divm1,divv,work1,work2)
         ! and averages the divergence on element boundaries
         ! In contrast to outpost(), which does not average
         ! when writing divergence in pressure ouput 
         ! -> therefore, slight discrepancy < ~ factor 2

         divmax = glmax(divm1, nx1*ny1*nz1*nelv)

         if (nid.eq.0) write(*,*) '||div||_max', Divmax


         if (mod(ISTEP,IOSTEP).eq.0.and. istep.gt.0) then
            !
            ! compute and output some postprocessing quantities

!           ! output divergence (in pressure field)
!           call outpost(vx,vy,vz,divv,t,'div')
!
!           ! Compute lambda_2
!           if (NID.eq.0) then
!              write(6,*) ISTEP,IOSTEP,TIME,' compute lambda2'
!           endif
!           call lambda2(t(1,1,1,1,1))
!
!           ! Output streamfunction phi and velocity v_s of streamwise direction
!           !
!           ! compute vorticity
!           call rzero(vorticity,3*n)
!           call comp_vort3(vorticity,work1,work2,vx,vy,vz)  
!           call copy(vorticity(1,1),work1,n);
!           call copy(vorticity(1,2),work2,n);
!           call copy(vorticity(1,3),work3,n);
!           call chsign(work1,n);
!           call chsign(work2,n);
!           call chsign(work3,n);
!           call rzero(h2,n)
!           call chsign(omega_s,n)
!           !
!           ! multiply with the mass matrix
!           call col3(rhs,omega_s,bm1,n)
!           ! setup Poisson problem: h2=0, h1=1
!           call rone(h1,n)
!           ! set solver tolerance
!           ! and save param22
!           toler = 1e-14
!           p22 = param(22)
!           param(22) = toler
!           maxit = 10000    
!           ! Solve Poisson equation:    
!           call hmholtz('PHI ',phi,rhs,h1,h2,v2mask,vmult,1,
!    $                   toler,maxit,1)
!           ! reset param22
!           param(22) = p22
!
!           call outpost(rhs,phi,v_s,pr,t,'stf')

         endif


!        ! Restart routines
!        ! (uncomment the INCLUDE statement at the beginning)
!        call checkpoint
!        ! This call is already executed in setics()/ic.f
!        ! However, it has the wrong time time-value (=0.0) 
!        ! when using our restarting, which initializes 'time' 
!        if (istep.eq.0.and.timeio.ne.0.0)  then
!           ntdump = int( (time+1e-14)/timeio )
!        endif


      ! output initial condition
      if (istep.eq.0) then
         call outpost(vx,vy,vz,pr,t,'init')
      endif

      return
      end

c-----------------------------------------------------------------------

      subroutine userbc (ix,iy,iz,iside,ieg)

         implicit none

         include 'SIZE_DEF'
         include 'SIZE'  ! LDIMT needed by NEKUSE
         include 'NEKUSE_DEF'
         include 'NEKUSE' ! u[xyz], [xyz]

         integer, intent(in) :: ix,iy,iz,iside,ieg

         ux =  0.0
         uy =  0.0
         uz =  0.0

         if (y .lt. 0) then

            ux = -1.0

         else

            ux =  1.0

         endif

      return
      end

c-----------------------------------------------------------------------

      subroutine useric (ix,iy,iz,ieg)

         use randgen ! rnd_loc()

         implicit none

         include 'SIZE_DEF'
         include 'SIZE'  ! LDIMT needed by NEKUSE
         include 'NEKUSE_DEF'
         include 'NEKUSE' ! u[xyz], [xyz]
         include 'USERPAR' ! init_amp

         integer, intent(in) :: ix,iy,iz,ieg

         !ux = 0.0
         !uy = 0.0
         !uz = 0.0

         ux = init_amp*rnd_loc(-1.0, 1.0)
         uy = init_amp*rnd_loc(-1.0, 1.0)
         uz = init_amp*rnd_loc(-1.0, 1.0)

      return
      end

c-----------------------------------------------------------------------

      subroutine usrdat

         use randgen ! zbqlini()

         implicit none

         include 'SIZE_DEF'
         include 'SIZE' ! NID
         include 'USERPAR'

         integer :: iseed
         real, external :: dnekclock ! defined in comm_mpi.f

         ! Read user module parameters
         call uprm_read


         ! initialise random number generator from the 'randgen' module
         ! only on rank=0
         if (NID.eq.0) then
            iseed = int(dnekclock())
            call zbqlini(iseed)
         endif

      return
      end

c-----------------------------------------------------------------------

      subroutine usrdat2

         implicit none

      return
      end

c-----------------------------------------------------------------------

      subroutine usrdat3

         implicit none

      return
      end

c------------------------------------------------------------------------
