c-----------------------------------------------------------------------
c  Couette flow
c  jcanton@mech.kth.se
c-----------------------------------------------------------------------

      subroutine uservp (ix,iy,iz,ieg)

         implicit none

         include 'SIZE_DEF'
         include 'SIZE'  ! LDIMT needed by NEKUSE
         include 'NEKUSE_DEF'
         include 'NEKUSE' ! udiff, utrans

         integer, intent(in) :: ix,iy,iz,ieg

         udiff = 0.0
         utrans = 0.0

      return
      end

c-----------------------------------------------------------------------

      subroutine userf  (ix,iy,iz,ieg)

         implicit none

         include 'SIZE_DEF'
         include 'SIZE'  ! LDIMT needed by NEKUSE
         include 'NEKUSE_DEF'
         include 'NEKUSE' ! ff[xyz]

         integer, intent(in) :: ix,iy,iz,ieg

         ffx = 0.0
         ffy = 0.0
         ffz = 0.0

      return
      end

c-----------------------------------------------------------------------

      subroutine userq  (ix,iy,iz,ieg)

         implicit none

         include 'SIZE_DEF'
         include 'SIZE'  ! LDIMT needed by NEKUSE
         include 'NEKUSE_DEF'
         include 'NEKUSE' ! qvol

         integer, intent(in) :: ix,iy,iz,ieg

         QVOL = 0.0
         ! SOURCE = 0.0 (cannot find where this is)

      return
      end

c-----------------------------------------------------------------------

      subroutine userchk

         implicit none

         interface
            FUNCTION wrap_revolve(check, capo, fine,
      +                           snaps_in, info, nid)
               implicit none
               integer :: wrap_revolve, check, capo, fine
               integer :: snaps_in, info, nid
            END FUNCTION wrap_revolve 
            SUBROUTINE wrap_revolve_reset()
               implicit none
            END SUBROUTINE wrap_revolve_reset
            FUNCTION adj_stack_empty()
               implicit none
               integer adj_stack_empty
            END FUNCTION adj_stack_empty 
         end interface


         include 'SIZE_DEF'
         include 'SIZE'  ! L[XYZ]1, LELV, NID
         include 'MASS_DEF'
         include 'MASS' ! BM1
         include 'TSTEP_DEF'
         include 'TSTEP' ! ISTEP,IOSTEP
         include 'INPUT_DEF'
         include 'INPUT' ! PARAM
         include 'SOLN_DEF'
         include 'SOLN'  ! V[XYZ],V[XYZ]P
         ! include 'CHKPOINT'

         include 'ADJOINT_DEF'
         include 'ADJOINT'

         !common /local_adj/ coeff_v, objective_v
         !real Ek,Ek1
         integer n, count  !, gstep
         integer :: whatodo, check, oldcapo, capo, fine, snaps_in, info
         integer :: ierr,tmp, ssize 
         real, allocatable  :: chkp(:,:,:,:)
         character*80 base,ctr,inputname1,filepath
         character*8, fmt, suffix
         real cfl,t0,t1,t2,t3,t4,t5,t6,twrite,tread
         logical :: exist,first,wcheckpoint,firstvx


         ! output initial condition
         ! testing only
         if (istep.eq.0) then
            call outpost(vx,vy,vz,pr,t,'ini')
         endif

         n=nx1*ny1*nz1*nelv
         capo = 0
         fine = 10  ! tell revolve how many time steps
         snaps_in=2 ! max number of time steps revolve saves
         info=2     ! described in the revolve paper
         first = .true.
         check = -1
         !call MPI_Comm_rank(MPI_COMM_WORLD,rank,ier)




      ALLOCATE(chkp(n,3,snaps_in,nbdinp))

      whatodo=wrap_revolve(check,capo,fine,snaps_in,info,nid)
      !if (nid.eq.0) write(*,*) 'whatodo = ', whatodo

      select case(whatodo) 
      case(2)
C        print *, 'Store in checkpoint number ',check, '.'
        call copy(chkp(:,1,check+1,1),vxlag(1,1,1,1,1),n)
        call copy(chkp(:,2,check+1,1),vylag(1,1,1,1,1),n)
        call copy(chkp(:,3,check+1,1),vzlag(1,1,1,1,1),n)
        call copy(chkp(:,1,check+1,2),vxlag(1,1,1,1,2),n)
        call copy(chkp(:,2,check+1,2),vylag(1,1,1,1,2),n)
        call copy(chkp(:,3,check+1,2),vzlag(1,1,1,1,2),n)
        call copy(chkp(:,1,check+1,3),vx,n)
        call copy(chkp(:,2,check+1,3),vy,n)
        call copy(chkp(:,3,check+1,3),vz,n)
      case default
        if(nid .eq. 0) then
          print *, 'Error!'
        end if
      end select

      ! revolve algorithm
      !
      do while (whatodo .ne. 6)
      oldcapo=capo+1;
      whatodo=wrap_revolve(check, capo, fine, snaps_in, info,nid);
      select case(whatodo) 
      case(1) 
         ! ADVANCE
C        print *, 'Advance from', oldcapo, ' to ', capo, '.'
        time = (oldcapo)*DT
        ifpert = .false.
C        npert=0
        ifadj  = .false.
        count=0; 
        do istep=oldcapo,capo
        call nek_advance
        call compute_cfl(cfl,vx,vy,vz,dt)
        if (nid.eq.0) write(*,*) 'cfl ',cfl 	
        end do
      case(2)
         ! STORE
C        print *, 'Store in checkpoint number ',check, '.'
        call copy(chkp(:,1,check+1,1),vxlag(1,1,1,1,1),n)
        call copy(chkp(:,2,check+1,1),vylag(1,1,1,1,1),n)
        call copy(chkp(:,3,check+1,1),vzlag(1,1,1,1,1),n)
        call copy(chkp(:,1,check+1,2),vxlag(1,1,1,1,2),n)
        call copy(chkp(:,2,check+1,2),vylag(1,1,1,1,2),n)
        call copy(chkp(:,3,check+1,2),vzlag(1,1,1,1,2),n)
        call copy(chkp(:,1,check+1,3),vx,n)
        call copy(chkp(:,2,check+1,3),vy,n)
        call copy(chkp(:,3,check+1,3),vz,n)
        if(firstvx .eqv. .true.) then
        firstvx=.false.
        end if
      case(3) 
         ! firsturn
        if(first .eqv. .true.) then 
        call copy(vxp,vx,n)
        call copy(vyp,vy,n)
        call copy(vzp,vz,n)
        first=.false.
        end if
C        call outpost(vx,vy,vz,pr,t,'lst')
C        REVERSE

         ifpert = .true.
         npert = 1 !this is in the common block from SIZE
         ifadj  = .true. 
C        call full_restart_save(istep)
         !t = real(gstep)*real(DT)
         !tp = real(gstep)*real(DT)
         !gstep=gstep-1
C         call outpost(vx,vy,vz,pr,t,'fdd')
C         call outpost(vxp,vyp,vzp,prp,tp,'adj')
         call nek_advance
         call compute_cfl(cfl,vx,vy,vz,dt)
         if (nid.eq.0) write(*,*) 'cfl ',cfl 	

      case(4) 
         ! there actually is no forward step here because
         ! we're not doing AD
         ! this is youturn
C        print *, 'Forward and reverse one step.'
C        FORWARD
        t = capo*DT
        ifpert = .false.
C        npert = 0 !this is in the common block from SIZE
        ifadj  = .false.
        istep=capo
C        print *, 'istep: ', istep, ' ', capo, ' ', fine, ' ', time
C        if (mod(istep,100).eq.0) then
C          t = real(gstep)*real(DT)
C          call outpost(vx,vy,vz,pr,t,'fdd')
C        end if
C        REVERSE
        
         ifpert = .true.
         npert = 1 !this is in the common block from SIZE
         ifadj  = .true. 
         call nek_advance
         if (mod(istep,100).eq.0) then
           !tp = real(gstep)*real(DT)
           call outpost(vxp,vyp,vzp,prp,tp,'adj')
         endif
         call compute_cfl(cfl,vx,vy,vz,dt)
         if (nid.eq.0) write(*,*) 'cfl ',cfl 	
         !gstep=gstep-1
      case(5)
C        print *, 'Restore from checkpoint number ', check
        call copy(vxlag(1,1,1,1,1),chkp(:,1,check+1,1),n)
        call copy(vylag(1,1,1,1,1),chkp(:,2,check+1,1),n)
        call copy(vzlag(1,1,1,1,1),chkp(:,3,check+1,1),n)
        call copy(vxlag(1,1,1,1,2),chkp(:,1,check+1,2),n)
        call copy(vylag(1,1,1,1,2),chkp(:,2,check+1,2),n)
        call copy(vzlag(1,1,1,1,2),chkp(:,3,check+1,2),n)
        call copy(vx,chkp(:,1,check+1,3),n)
        call copy(vy,chkp(:,2,check+1,3),n)
        call copy(vz,chkp(:,3,check+1,3),n)
      case(6)
        if(nid .eq. 0) then
          print *, 'Done'
        end if
      case default
        if(nid .eq. 0) then
          print *, 'Error!'
        end if
      end select
      enddo


      !tp = real(gstep)*real(DT)
C      call outpost(vxp,vyp,vzp,prp,tp,'rev')
      DEALLOCATE(chkp)
      ! reset revolve so it can be used for the next run
      call wrap_revolve_reset();

      ssize=ssize-1
      !end do


      call exitt()
      return
      end

c-----------------------------------------------------------------------

      subroutine userbc (ix,iy,iz,iside,ieg)

         implicit none

         include 'SIZE_DEF'
         include 'SIZE'  ! LDIMT needed by NEKUSE
         include 'NEKUSE_DEF'
         include 'NEKUSE' ! u[xyz], [xyz]
         include 'SOLN_DEF'
         include 'SOLN' ! jp

         integer, intent(in) :: ix,iy,iz,iside,ieg

         if (jp.eq.0) then
            ! non-linear mode
            ! direct problem
            ! (time goes forward)
            ux =  0.0
            uy =  0.0
            uz =  0.0
            if (y .lt. 0) then
               ux = -1.0
            else
               ux =  1.0
            endif
         else
            ! perturbation mode
            ! adjoint problem
            ! (time goes backward)
            ux =  0.0
            uy =  0.0
            uz =  0.0
         endif

      return
      end

c-----------------------------------------------------------------------

      subroutine useric (ix,iy,iz,ieg)

         use randgen ! rnd_loc()

         implicit none

         include 'SIZE_DEF'
         include 'SIZE'  ! LDIMT needed by NEKUSE
         include 'NEKUSE_DEF'
         include 'NEKUSE' ! u[xyz], [xyz]
         include 'USERPAR' ! init_amp

         integer, intent(in) :: ix,iy,iz,ieg

         ux = init_amp*rnd_loc(-1.0, 1.0)
         uy = init_amp*rnd_loc(-1.0, 1.0)
         uz = init_amp*rnd_loc(-1.0, 1.0)

      return
      end

c-----------------------------------------------------------------------

      subroutine usrdat

         use randgen ! zbqlini()

         implicit none

         include 'SIZE_DEF'
         include 'SIZE' ! NID
         include 'PARALLEL_DEF' 
         include 'PARALLEL' ! WDSIZE
         include 'USERPAR'

         integer :: iseed
         real, external :: dnekclock ! defined in comm_mpi.f

         ! Read user module parameters
         call uprm_read


         ! initialise random number generator from the 'randgen' module
         ! only on rank=0
         if (NID.eq.0) then
            iseed = int(dnekclock())
            call zbqlini(iseed)
         endif
         call bcast(zbqlix, WDSIZE)

      return
      end

c-----------------------------------------------------------------------

      subroutine usrdat2

         implicit none

      return
      end

c-----------------------------------------------------------------------

      subroutine usrdat3

         implicit none

      return
      end

c------------------------------------------------------------------------
